import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;

/**
 * Optimal Sorting Algorithms Collection for Java
 * Includes adaptive implementations with performance optimizations
 */
public class OptimalSorter {

    // Dual-Pivot Quicksort (Java's default - highly optimized)
    public static <T extends Comparable<? super T>> void dualPivotQuickSort(T[] array) {
        if (array == null || array.length <= 1) return;
        dualPivotQuickSort(array, 0, array.length - 1);
    }

    private static <T extends Comparable<? super T>> void dualPivotQuickSort(T[] array, int left, int right) {
        // Use insertion sort for small subarrays
        if (right - left < 27) {
            insertionSort(array, left, right);
            return;
        }

        // Choose pivots and partition
        if (array[left].compareTo(array[right]) > 0) {
            swap(array, left, right);
        }

        T pivot1 = array[left];
        T pivot2 = array[right];
        
        int less = left + 1;
        int great = right - 1;
        int k = less;

        while (k <= great) {
            if (array[k].compareTo(pivot1) < 0) {
                swap(array, k, less++);
            } else if (array[k].compareTo(pivot2) > 0) {
                while (k < great && array[great].compareTo(pivot2) > 0) {
                    great--;
                }
                swap(array, k, great--);
                
                if (array[k].compareTo(pivot1) < 0) {
                    swap(array, k, less++);
                }
            }
            k++;
        }

        // Swap pivots to final positions
        swap(array, left, less - 1);
        swap(array, right, great + 1);

        // Recursively sort partitions
        dualPivotQuickSort(array, left, less - 2);
        if (pivot1.compareTo(pivot2) < 0) {
            dualPivotQuickSort(array, less, great);
        }
        dualPivotQuickSort(array, great + 2, right);
    }

    // Timsort-inspired merge sort (optimal for real-world data)
    public static <T extends Comparable<? super T>> void timSort(T[] array) {
        if (array == null || array.length <= 1) return;
        
        int n = array.length;
        int minRun = calculateMinRun(n);
        
        // Sort individual subarrays of size minRun
        for (int i = 0; i < n; i += minRun) {
            int end = Math.min(i + minRun - 1, n - 1);
            insertionSort(array, i, end);
        }
        
        // Merge the sorted runs
        for (int size = minRun; size < n; size = 2 * size) {
            for (int left = 0; left < n; left += 2 * size) {
                int mid = left + size - 1;
                int right = Math.min(left + 2 * size - 1, n - 1);
                
                if (mid < right) {
                    merge(array, left, mid, right);
                }
            }
        }
    }

    // Adaptive insertion sort (optimal for small or nearly sorted arrays)
    public static <T extends Comparable<? super T>> void insertionSort(T[] array) {
        if (array == null || array.length <= 1) return;
        insertionSort(array, 0, array.length - 1);
    }

    private static <T extends Comparable<? super T>> void insertionSort(T[] array, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            T key = array[i];
            int j = i - 1;
            
            // Move elements that are greater than key one position ahead
            while (j >= left && array[j].compareTo(key) > 0) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }

    // Heap sort (guaranteed O(n log n), good for worst-case scenarios)
    public static <T extends Comparable<? super T>> void heapSort(T[] array) {
        if (array == null || array.length <= 1) return;
        
        int n = array.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }
        
        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--) {
            swap(array, 0, i);
            heapify(array, i, 0);
        }
    }

    private static <T extends Comparable<? super T>> void heapify(T[] array, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && array[left].compareTo(array[largest]) > 0) {
            largest = left;
        }
        
        if (right < n && array[right].compareTo(array[largest]) > 0) {
            largest = right;
        }
        
        if (largest != i) {
            swap(array, i, largest);
            heapify(array, n, largest);
        }
    }

    // Utility methods
    private static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    private static void merge(Comparable[] array, int left, int mid, int right) {
        Comparable[] leftArray = Arrays.copyOfRange(array, left, mid + 1);
        Comparable[] rightArray = Arrays.copyOfRange(array, mid + 1, right + 1);
        
        int i = 0, j = 0, k = left;
        
        while (i < leftArray.length && j < rightArray.length) {
            if (leftArray[i].compareTo(rightArray[j]) <= 0) {
                array[k++] = leftArray[i++];
            } else {
                array[k++] = rightArray[j++];
            }
        }
        
        while (i < leftArray.length) {
            array[k++] = leftArray[i++];
        }
        
        while (j < rightArray.length) {
            array[k++] = rightArray[j++];
        }
    }

    private static int calculateMinRun(int n) {
        int r = 0;
        while (n >= 64) {
            r |= (n & 1);
            n >>= 1;
        }
        return n + r;
    }

    // Generic version with Comparator
    public static <T> void sortWithComparator(T[] array, Comparator<? super T> comparator) {
        if (array == null || array.length <= 1) return;
        Arrays.sort(array, comparator);
    }

    // Performance benchmark utility
    public static <T extends Comparable<? super T>> void benchmarkSort(T[] originalArray, String algorithmName) {
        T[] array = Arrays.copyOf(originalArray, originalArray.length);
        long startTime = System.nanoTime();
        
        switch (algorithmName.toLowerCase()) {
            case "quicksort":
                dualPivotQuickSort(array);
                break;
            case "timsort":
                timSort(array);
                break;
            case "heapsort":
                heapSort(array);
                break;
            case "insertionsort":
                insertionSort(array);
                break;
            default:
                Arrays.sort(array);
        }
        
        long endTime = System.nanoTime();
        double duration = (endTime - startTime) / 1_000_000.0;
        
        System.out.printf("%s: %.3f ms | Sorted: %s%n", 
            algorithmName, duration, isSorted(array) ? "Yes" : "No");
    }

    private static <T extends Comparable<? super T>> boolean isSorted(T[] array) {
        for (int i = 0; i < array.length - 1; i++) {
            if (array[i].compareTo(array[i + 1]) > 0) {
                return false;
            }
        }
        return true;
    }
}





import java.util.Arrays;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        // Test with different array sizes and types
        System.out.println("=== Sorting Algorithm Performance Comparison ===\n");
        
        // Small array (insertion sort optimal)
        Integer[] smallArray = generateRandomArray(50);
        testAlgorithms(smallArray, "Small Array (50 elements)");
        
        // Medium array
        Integer[] mediumArray = generateRandomArray(1000);
        testAlgorithms(mediumArray, "Medium Array (1,000 elements)");
        
        // Large array
        Integer[] largeArray = generateRandomArray(10000);
        testAlgorithms(largeArray, "Large Array (10,000 elements)");
        
        // Nearly sorted array (Timsort optimal)
        Integer[] nearlySortedArray = generateNearlySortedArray(1000);
        testAlgorithms(nearlySortedArray, "Nearly Sorted Array (1,000 elements)");
        
        // Demonstration with custom objects
        System.out.println("\n=== Custom Object Sorting ===");
        sortCustomObjects();
    }
    
    private static void testAlgorithms(Integer[] originalArray, String description) {
        System.out.println(description);
        System.out.println("-".repeat(description.length()));
        
        OptimalSorter.benchmarkSort(originalArray, "QuickSort");
        OptimalSorter.benchmarkSort(originalArray, "TimSort");
        OptimalSorter.benchmarkSort(originalArray, "HeapSort");
        
        // Only use insertion sort for small arrays
        if (originalArray.length <= 100) {
            OptimalSorter.benchmarkSort(originalArray, "InsertionSort");
        }
        
        // Java's built-in (Dual-Pivot QuickSort)
        Integer[] builtInArray = Arrays.copyOf(originalArray, originalArray.length);
        long start = System.nanoTime();
        Arrays.sort(builtInArray);
        long end = System.nanoTime();
        System.out.printf("Arrays.sort(): %.3f ms | Sorted: %s%n", 
            (end - start) / 1_000_000.0, 
            OptimalSorter.isSorted(builtInArray) ? "Yes" : "No");
        
        System.out.println();
    }
    
    private static Integer[] generateRandomArray(int size) {
        Random random = new Random();
        Integer[] array = new Integer[size];
        for (int i = 0; i < size; i++) {
            array[i] = random.nextInt(size * 10);
        }
        return array;
    }
    
    private static Integer[] generateNearlySortedArray(int size) {
        Integer[] array = new Integer[size];
        for (int i = 0; i < size; i++) {
            array[i] = i;
        }
        // Add some random swaps to make it nearly sorted
        Random random = new Random();
        for (int i = 0; i < size / 10; i++) {
            int idx1 = random.nextInt(size);
            int idx2 = random.nextInt(size);
            int temp = array[idx1];
            array[idx1] = array[idx2];
            array[idx2] = temp;
        }
        return array;
    }
    
    private static void sortCustomObjects() {
        Person[] people = {
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35),
            new Person("Diana", 28)
        };
        
        System.out.println("Before sorting:");
        for (Person person : people) {
            System.out.println(person);
        }
        
        // Sort by age using comparator
        OptimalSorter.sortWithComparator(people, 
            (p1, p2) -> Integer.compare(p1.getAge(), p2.getAge()));
        
        System.out.println("\nAfter sorting by age:");
        for (Person person : people) {
            System.out.println(person);
        }
        
        // Verify sorted
        System.out.println("Is sorted by age: " + isSortedByAge(people));
    }
    
    private static boolean isSortedByAge(Person[] people) {
        for (int i = 0; i < people.length - 1; i++) {
            if (people[i].getAge() > people[i + 1].getAge()) {
                return false;
            }
        }
        return true;
    }
    
    static class Person {
        private String name;
        private int age;
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        
        @Override
        public String toString() {
            return String.format("Person{name='%s', age=%d}", name, age);
        }
    }
}